# Q-080

## 題目資訊

**ID:** `Q-080`  
**來源:** Official Practice Exam  
**難度:** `L2-Intermediate`

---

## 題目內容

### 題幹

The marketing team is looking to share data in an aggregate table with the sales organization, but the field names used by the teams do not match, and a number of marketing-specific fields have not been approved for the sales org.

Which of the following solutions addresses the situation while emphasizing simplicity?

### 選項

**A.** Create a view on the marketing table selecting only those fields approved for the sales team; alias the names of any fields that should be standardized to the sales naming conventions.

**B.** Create a new table with the required schema and use Delta Lake's DEEP CLONE functionality to sync up changes committed to one table to the corresponding table.

**C.** Use a CTAS statement to create a derivative table from the marketing table; configure a production job to propagate changes.

**D.** Add a parallel table write to the current production pipeline, updating a new sales table that varies as required from the marketing table.

**E.** Instruct the marketing team to download results as a CSV and email them to the sales organization.

---

## 標籤 (Tags)

### Topic Tags
- `Views`
- `Data-Governance`
- `Delta-Lake`

### Trap Tags
- `Concept-Confusion`

### Level Tag
- `L2-Intermediate`

---

---

# 題目解析

## 題目回顧

**題目 ID:** `Q-080`  
**題目連結:** [點此返回題目](#q-080)  
**正解:** `A`

---

## 📍 考點識別

### 主要考點
**核心技術:** Views (視圖)  
**知識領域:** 安全與治理 / 資料共享 / 存取控制  
**關鍵概念:**
- 視圖作為資料存取控制的機制
- 欄位篩選與別名（Alias）
- 簡單性與維護成本的權衡

### 次要考點
- Delta Lake DEEP CLONE 的使用場景
- CTAS (CREATE TABLE AS SELECT) 與資料管道設計
- 資料共享的最佳實踐

---

## ✅ 正解說明

### 為什麼 A 是正確的？

**技術原理:**

視圖（View）是 SQL 資料庫中的虛擬表，它不儲存實際資料，而是儲存一個查詢定義。每次查詢視圖時，底層的查詢會即時執行，返回最新的資料。

**符合需求:**

1. **簡單性（Simplicity）**：建立視圖是 SQL 標準語法，不需要額外的資料同步機制或作業調度，實作與維護成本最低。

2. **欄位篩選**：透過 `SELECT` 語句，可以輕鬆選擇已批准的欄位，自動排除未經授權的欄位。

3. **欄位重新命名**：使用別名（Alias）可以將欄位名稱轉換為銷售團隊的命名規範，無需修改底層表結構。

4. **即時性**：視圖不儲存物理資料，因此行銷表的任何變更都會即時反映在視圖中，確保銷售團隊始終存取最新資料。

5. **無額外儲存成本**：視圖不佔用額外的儲存空間，不會產生資料冗餘。

**實務應用:**

```sql
-- 建立視圖範例
CREATE VIEW sales_marketing_view AS
SELECT
    campaign_id AS sale_campaign_id,           -- 欄位重新命名
    campaign_name AS sale_campaign_name,
    total_revenue AS revenue,
    conversion_rate
    -- 排除行銷專用欄位，如內部成本、實驗性指標等
FROM marketing_aggregate_table
WHERE campaign_status = 'approved';           -- 可加入額外的篩選條件

-- 銷售團隊查詢視圖
SELECT * FROM sales_marketing_view
WHERE revenue > 100000;
```

---

## ❌ 錯誤選項排除

### 選項 B：使用 DEEP CLONE 同步表

**為什麼錯誤：**

1. **違反簡單性原則**：DEEP CLONE 會建立獨立的表副本，需要定期執行 CLONE 指令來同步變更，增加維護複雜度。

2. **無法自動同步**：DEEP CLONE 是一次性操作，不會自動傳播後續的變更，必須配置調度作業來定期執行。

3. **儲存成本**：DEEP CLONE 會複製完整的資料與歷史記錄，產生額外的儲存成本。

4. **欄位重新命名困難**：DEEP CLONE 會保留原始表的 Schema，需要額外的 ALTER TABLE 語句來重新命名欄位。

**陷阱設計：**  
DEEP CLONE 是 Delta Lake 的強大功能，容易讓考生聯想到「資料複製與同步」，但題目要求「簡單性」，DEEP CLONE 明顯過於複雜。

```sql
-- DEEP CLONE 範例（不推薦用於此情境）
CREATE TABLE sales_table DEEP CLONE marketing_aggregate_table;

-- 問題：後續變更不會自動同步
-- 需要定期執行：
CREATE OR REPLACE TABLE sales_table DEEP CLONE marketing_aggregate_table;
```

---

### 選項 C：使用 CTAS 與生產作業傳播變更

**為什麼錯誤：**

1. **增加維護負擔**：需要配置與維護生產作業（Production Job）來定期執行 CTAS，增加調度器的複雜度與故障風險。

2. **資料延遲**：CTAS 建立的是靜態表，資料更新取決於作業執行頻率，無法做到即時同步。

3. **儲存冗餘**：CTAS 會建立獨立的實體表，產生資料冗餘與額外的儲存成本。

4. **超出需求**：題目只要求共享資料，不需要建立獨立的資料管道。

**陷阱設計：**  
CTAS 是常見的 ETL 模式，但不適合簡單的資料共享情境。

```sql
-- CTAS 範例（過於複雜）
CREATE TABLE sales_table AS
SELECT
    campaign_id AS sale_campaign_id,
    campaign_name AS sale_campaign_name,
    total_revenue AS revenue
FROM marketing_aggregate_table;

-- 問題：需要配置 Job 來定期執行
-- Databricks Workflow:
-- Job: Refresh Sales Table
-- Schedule: Every 1 hour
-- Task: CREATE OR REPLACE TABLE sales_table AS ...
```

---

### 選項 D：新增平行表寫入

**為什麼錯誤：**

1. **侵入性修改**：需要修改現有的生產管道，增加風險與測試成本。

2. **維護兩個寫入邏輯**：必須同時維護行銷表與銷售表的寫入邏輯，增加程式碼複雜度與錯誤風險。

3. **資料一致性風險**：如果兩個表的寫入邏輯不一致，可能導致資料不一致問題。

4. **效能影響**：平行寫入會增加管道的執行時間與資源消耗。

**陷阱設計：**  
平行寫入看似能解決問題，但違反了「簡單性」與「不修改現有管道」的最佳實踐。

```python
# 平行寫入範例（不推薦）
df = spark.read.table("source_table")

# 寫入行銷表
df.select("campaign_id", "campaign_name", "total_revenue", "internal_cost") \
  .write.mode("append").saveAsTable("marketing_table")

# 同時寫入銷售表（增加複雜度）
df.select(
    col("campaign_id").alias("sale_campaign_id"),
    col("campaign_name").alias("sale_campaign_name"),
    "total_revenue"
  ) \
  .write.mode("append").saveAsTable("sales_table")

# 問題：兩個寫入邏輯必須同步維護
```

---

### 選項 E：下載 CSV 並透過電子郵件發送

**為什麼錯誤：**

1. **完全違反現代資料工程原則**：手動下載與傳遞資料是過時且不可靠的做法。

2. **無即時性**：資料更新取決於手動操作的頻率，無法做到即時同步。

3. **安全性風險**：透過電子郵件傳遞敏感資料存在嚴重的安全隱患。

4. **無審計追蹤**：無法追蹤資料的存取與使用情況。

5. **人為錯誤**：容易出現檔案遺失、版本混淆等問題。

**陷阱設計：**  
這是一個明顯不合理的選項，用於測試考生是否能排除不專業的做法。

---

## 🧠 記憶法

### 口訣

**「視圖簡單又即時，別名篩選不佔地」**

- **視圖簡單** - View 是最簡單的資料共享機制
- **即時** - 視圖查詢即時反映底層表的變更
- **別名** - 使用 Alias 重新命名欄位
- **篩選** - SELECT 語句篩選欄位
- **不佔地** - 視圖不佔用額外儲存空間

### 對比表：資料共享方案比較

| 方案 | 簡單性 | 即時性 | 儲存成本 | 維護成本 | 適用場景 |
|-----|-------|-------|---------|---------|---------|
| **View** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐（無額外成本） | ⭐⭐⭐⭐⭐ | 簡單的資料共享與欄位篩選 |
| **DEEP CLONE** | ⭐⭐ | ⭐⭐（需手動觸發） | ⭐（複製完整資料） | ⭐⭐（需定期執行） | 資料備份、測試環境 |
| **CTAS + Job** | ⭐⭐ | ⭐⭐⭐（取決於調度頻率） | ⭐（建立獨立表） | ⭐⭐（需維護 Job） | 需要資料轉換的 ETL |
| **平行寫入** | ⭐ | ⭐⭐⭐⭐⭐ | ⭐（建立獨立表） | ⭐（需修改管道） | 完全不同的資料模型 |

### 決策樹

```
需要共享資料？
├─ 是否需要即時性？
│  ├─ 是 → 使用 View
│  └─ 否 → 考慮 CTAS + Job
│
├─ 是否需要篩選欄位或重新命名？
│  ├─ 是 → 使用 View
│  └─ 否 → 考慮 DEEP CLONE
│
└─ 是否強調簡單性？
   ├─ 是 → 使用 View ✅
   └─ 否 → 考慮其他方案
```

---

## 📚 官方文件

### 主要參考
1. **Databricks Views 文件**  
   [Create and use views](https://docs.databricks.com/sql/language-manual/sql-ref-syntax-ddl-create-view.html)

2. **Delta Lake DEEP CLONE 文件**  
   [Clone a Delta Lake table](https://docs.databricks.com/delta/clone.html)

### 延伸閱讀
3. **Unity Catalog 權限管理**  
   [Manage privileges in Unity Catalog](https://docs.databricks.com/data-governance/unity-catalog/manage-privileges/index.html)

4. **資料共享最佳實踐**  
   [Data sharing best practices](https://docs.databricks.com/data-sharing/index.html)

---

## 🎓 學習建議

1. **理解視圖的本質**：視圖是虛擬表，不儲存資料，僅儲存查詢定義。

2. **掌握 Alias 語法**：熟練使用 `AS` 關鍵字來重新命名欄位。

3. **比較不同的資料複製方案**：DEEP CLONE、SHALLOW CLONE、CTAS 各有適用場景。

4. **簡單性原則**：在多個解決方案中，優先選擇最簡單、維護成本最低的方案。

5. **實務練習**：在 Databricks 環境中建立視圖，觀察資料變更如何即時反映。

---

## 💡 實務提示

### 何時使用 View？
- ✅ 需要篩選欄位或重新命名欄位
- ✅ 需要即時反映底層表的變更
- ✅ 不希望產生額外的儲存成本
- ✅ 不需要修改資料，僅需要查詢

### 何時不使用 View？
- ❌ 需要在視圖中進行複雜的資料轉換（可能影響查詢效能）
- ❌ 需要對資料進行寫入操作（View 預設為唯讀）
- ❌ 需要保留歷史快照（View 總是反映最新資料）

### View 效能注意事項
- 視圖的查詢效能取決於底層表的效能
- 如果視圖包含複雜的 JOIN 或聚合，建議使用實體化視圖（Materialized View）
- 在 Databricks SQL 中，可以使用 Query History 分析視圖的查詢效能

---

## 🔗 相關題目

- Q-XXX: Unity Catalog 權限管理
- Q-XXX: Delta Lake DEEP CLONE 與 SHALLOW CLONE 的差異
- Q-XXX: 實體化視圖（Materialized View）的使用場景

---

**最後更新:** 2026-01-15
