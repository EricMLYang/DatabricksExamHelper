# Question #109

---

## 題目資訊

### 題目編號
**ID:** `Q-109`

### 來源
**來源:** Mock Exam / Community Contributed

### 難度等級
**難度:** `L1-Basic`

---

## 題目內容

### 題幹

A Delta Lake table representing metadata about content posts from users has the following schema:

```sql
user_id LONG, 
post_text STRING, 
post_id STRING, 
longitude FLOAT, 
latitude FLOAT, 
post_time TIMESTAMP, 
date DATE
```

Based on the above schema, which column is a **good candidate for partitioning** the Delta Table?

### 選項

- **A.** post_time
- **B.** latitude
- **C.** post_id
- **D.** user_id
- **E.** date

---

## 標籤系統

### Topic Tags (技術主題標籤)
**Topics:** `Delta-Lake`, `Partitioning`, `Performance-Optimization`

### Trap Tags (陷阱類型標籤)
**Traps:** `Cardinality-Trap`, `Data-Type-Confusion`

### Knowledge Domain (知識領域)
**Domain:** Data Engineering / Performance & Cost Optimization

---

## 答案與來源

### 正確答案
**正解:** `E`

### 答案來源
- **來源標註答案:** E
- **社群共識:** E

---

# 題目解析

---

## 📍 考點識別

**核心技術:** Delta Lake Partitioning Strategy  
**關鍵概念:** 分區欄位選擇、Cardinality、Partition Pruning

---

## ✅ 正解說明

### 為什麼 E (date) 是最佳答案？

**理由：**

```sql
-- 使用 date 分區（推薦）
CREATE TABLE posts (
    user_id LONG,
    post_text STRING,
    post_id STRING,
    longitude FLOAT,
    latitude FLOAT,
    post_time TIMESTAMP,
    date DATE
) USING DELTA
PARTITIONED BY (date);

-- 目錄結構：
/posts/
  ├── date=2026-01-01/ (適中數量的檔案)
  ├── date=2026-01-02/
  └── date=2026-01-03/
```

**✅ date 的優勢：**

| 優勢 | 說明 |
|------|------|
| **低 Cardinality** | 每天一個分區，數量可控 |
| **查詢模式匹配** | 常見查詢：「最近 7 天」、「特定日期」 |
| **Partition Pruning** | 可跳過無關日期的資料 |
| **檔案大小平衡** | 每個分區有適量資料 |
| **易於管理** | 可按日期刪除舊資料 |

**典型查詢：**

```sql
-- Partition Pruning 生效
SELECT * FROM posts 
WHERE date >= '2026-01-01' AND date <= '2026-01-07';
-- ✅ 只掃描 7 個分區

-- 刪除舊資料容易
DELETE FROM posts WHERE date < '2025-01-01';
-- ✅ 直接刪除整個分區目錄
```

---

## ❌ 錯誤選項排除

### A - post_time (TIMESTAMP)

**為什麼不好？**

```sql
-- TIMESTAMP 分區問題
PARTITIONED BY (post_time)

-- 可能產生的分區：
/posts/
  ├── post_time=2026-01-15 10:23:45.123/
  ├── post_time=2026-01-15 10:23:45.456/
  ├── post_time=2026-01-15 10:23:46.789/
  └── ... (可能數百萬個分區！)
```

**❌ 問題：**
- **超高 Cardinality** - 每秒/毫秒一個分區
- **分區數爆炸** - 可能產生數百萬個分區
- **小檔案問題** - 每個分區檔案極小
- **效能災難** - Metadata 過大，列出分區緩慢

### B - latitude (FLOAT)

**為什麼不好？**

```sql
-- FLOAT 分區問題
PARTITIONED BY (latitude)

-- 可能產生的分區：
/posts/
  ├── latitude=25.0334567/
  ├── latitude=25.0334568/
  ├── latitude=25.0334569/
  └── ... (幾乎無限個分區！)
```

**❌ 問題：**
- **連續值** - FLOAT 幾乎每個值都不同
- **無限 Cardinality** - 分區數無上限
- **無法有效 Pruning** - 查詢很少精確匹配 FLOAT

### C - post_id (STRING)

**為什麼不好？**

```sql
-- post_id 分區問題
PARTITIONED BY (post_id)

-- 每篇貼文一個分區：
/posts/
  ├── post_id=abc123/
  ├── post_id=def456/
  └── ... (百萬級分區)
```

**❌ 問題：**
- **唯一值** - 每個 post_id 都不同
- **極高 Cardinality** - 分區數 = 貼文數
- **無用的分區** - 每個分區只有一筆資料

### D - user_id (LONG)

**為什麼不好？**

```sql
-- user_id 分區問題
PARTITIONED BY (user_id)

-- 每個使用者一個分區：
/posts/
  ├── user_id=1001/
  ├── user_id=1002/
  └── ... (數十萬個分區)
```

**❌ 問題：**
- **高 Cardinality** - 分區數 = 使用者數
- **資料傾斜** - 活躍用戶分區大，一般用戶分區小
- **不符查詢模式** - 很少查詢特定使用者的所有貼文

---

## 🧠 記憶法

### 口訣

**「分區選日期，低基數穩定」**

```
Good Partition Column:
✅ 低 Cardinality（Low Cardinality）
✅ 符合查詢模式（Query Pattern）
✅ 資料分布均勻（Even Distribution）
```

### 分區選擇標準

| 標準 | DATE | TIMESTAMP | post_id | user_id | lat/lon |
|------|------|-----------|---------|---------|---------|
| **Cardinality** | ✅ 低 | ❌ 極高 | ❌ 極高 | ⚠️ 高 | ❌ 極高 |
| **分區數量** | 數百 | 數百萬 | 數百萬 | 數萬 | 無限 |
| **適合分區** | ✅ 是 | ❌ 否 | ❌ 否 | ❌ 否 | ❌ 否 |

### 快速判斷

```
分區欄位選擇優先順序：

1. ✅ DATE/日期類型（第一選擇）
2. ⚠️ 低基數類別欄位（region, category）
3. ❌ TIMESTAMP（太細粒度）
4. ❌ 連續數值（FLOAT, DOUBLE）
5. ❌ 唯一識別碼（ID, UUID）
```

---

## 📚 官方文件

- [Partitioning Best Practices](https://docs.databricks.com/delta/best-practices.html#partitioning)
- [When to Partition](https://docs.databricks.com/delta/partition.html)

---

## 💡 實務建議

### 最佳實務

```sql
-- ✅ 好的分區策略
CREATE TABLE posts
PARTITIONED BY (date);  -- 低基數，符合查詢模式

-- ⚠️ 如果需要更細粒度，可以多欄位分區
CREATE TABLE posts
PARTITIONED BY (date, region);  -- 仍保持低基數

-- ❌ 避免
CREATE TABLE posts
PARTITIONED BY (post_time);  -- 太多分區

CREATE TABLE posts
PARTITIONED BY (user_id);  -- 資料傾斜
```

### Cardinality 指南

| 分區數量 | 評估 | 範例 |
|---------|------|------|
| **< 1,000** | ✅ 理想 | date, region, category |
| **1,000 - 10,000** | ⚠️ 可接受 | date + region |
| **> 10,000** | ❌ 太多 | timestamp, user_id, id |

---

## 🎯 考試技巧

**看到分區題目，快速排除法：**

1. ✅ **有 DATE 欄位？** → 優先選擇
2. ❌ **TIMESTAMP？** → 排除（太細粒度）
3. ❌ **FLOAT/連續值？** → 排除（無限基數）
4. ❌ **ID/唯一值？** → 排除（每行一個分區）

**本題答案：E (date)** ✅

---

**[返回題目](#question-109)**