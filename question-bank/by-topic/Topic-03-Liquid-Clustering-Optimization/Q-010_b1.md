# Question #010

---

## 題目資訊
### 題目編號
**ID:** `Q-010`
### 來源
**來源:** Sample
### 難度等級
**難度:** `L2-Intermediate`

---

## 題目內容
### 題幹
A data engineer has a Delta Lake table named 'orders_archive' created using the following command:

```sql
CREATE TABLE orders_archive
DEEP CLONE orders
```

They want to sync up the new changes in the orders table to the clone.

Which of the following commands can be run to achieve this task?

### 選項
- **A.** `SYNC orders_archive`
- **B.** `INSERT OVERWRITE orders_archive SELECT * FROM orders`
- **C.** `REFRESH orders_archive`
- **D.** `CREATE OR REPLACE TABLE orders_archive DEEP CLONE orders`

---

## 標籤系統
### Topic Tags (技術主題標籤)
**Topics:** `Delta-Lake`, `Delta-Optimization`
### Trap Tags (陷阱類型標籤)
**Traps:** `Command-Purpose`, `Syntax-Confusion`
### Knowledge Domain (知識領域)
**Domain:** Data Engineering / Development

---

## 答案與來源
### 正確答案
**正解:** `D`
### 答案來源
- **來源標註答案:** D
- **社群共識:** D

---

# 題目解析

---

## 📍 考點識別
**核心技術:** Delta Lake Cloning (DEEP CLONE)
**關鍵概念:** Incremental Clone Sync, Table Versioning
**題目關鍵字：**
- **DEEP CLONE**: 建立獨立的完整副本，包含所有資料與 metadata
- **Sync changes**: 將來源表的新變更同步到克隆表
- **CREATE OR REPLACE TABLE**: 重新執行 CLONE 操作以同步變更

---

## ✅ 正解說明
### 為什麼 D 是正確答案？

**技術原理：**

DEEP CLONE 建立的是一個**完全獨立的副本**，包含：
- 複製所有資料檔案（而非僅參考）
- 獨立的 transaction log
- 完整的版本歷史

當來源表（`orders`）有新變更時，克隆表（`orders_archive`）**不會自動同步**。要同步變更，需要**重新執行 CLONE 操作**。

**為什麼使用 CREATE OR REPLACE TABLE？**

```sql
CREATE OR REPLACE TABLE orders_archive
DEEP CLONE orders
```

此指令會：
1. **增量同步**：只複製自上次 CLONE 以來的新變更（不是完整重建）
2. **保留歷史**：在 `orders_archive` 建立新版本，不會刪除原有歷史
3. **高效率**：利用 Delta Lake 的 incremental clone 機制，只處理差異部分

**驗證方式：**
```sql
DESCRIBE HISTORY orders_archive;
```
會看到新的 `CLONE` 操作版本記錄。

---

## ❌ 錯誤選項排除

### A. `SYNC orders_archive`
**為什麼錯誤？**
- **不存在的指令**：Delta Lake 沒有 `SYNC` 指令
- **陷阱設計**：故意使用直觀但不存在的語法誘導誤選

### B. `INSERT OVERWRITE orders_archive SELECT * FROM orders`
**為什麼錯誤？**
- **會遺失歷史**：`INSERT OVERWRITE` 會替換所有資料，但**不會保留 Delta Lake 的版本歷史**
- **無法 Time Travel**：執行後只會有一個版本，失去 CLONE 的版本管理優勢
- **不等同於 CLONE**：這是資料層面的覆寫，而非 metadata 層面的同步

### C. `REFRESH orders_archive`
**為什麼錯誤？**
- **指令用途不符**：`REFRESH` 用於重新載入 external table 的 metadata（針對外部資料來源）
- **不適用 Delta Lake**：Delta Lake managed table 不需要 `REFRESH`
- **概念混淆**：與資料快取刷新（cache refresh）是不同概念

---

## 🧠 記憶法

### 口訣
**「CLONE 要同步，重跑 CREATE OR REPLACE」**

### 比較表：DEEP CLONE vs SHALLOW CLONE vs INSERT OVERWRITE

| 特性 | DEEP CLONE | SHALLOW CLONE | INSERT OVERWRITE |
|------|-----------|---------------|------------------|
| **資料複製** | ✅ 完整複製資料檔案 | ❌ 只複製 metadata | ✅ 覆寫資料 |
| **獨立性** | ✅ 完全獨立 | ⚠️ 共享資料檔案 | ✅ 獨立 |
| **保留版本歷史** | ✅ 是 | ✅ 是 | ❌ 否（只有新版本） |
| **增量同步** | ✅ 支援 | ✅ 支援 | ❌ 全量覆寫 |
| **同步指令** | `CREATE OR REPLACE` | `CREATE OR REPLACE` | 不適用（每次都是全量） |
| **適用場景** | 長期備份、跨環境複製 | 測試環境、暫時性克隆 | 簡單的資料覆寫 |

### 關鍵差異圖示
```
來源表 orders (v1 → v2 → v3 → v4)
                    ↓ DEEP CLONE (第一次)
克隆表 orders_archive (v1' → v2' → v3')
                    ↓ 來源表有新變更 (v4)
                    ↓ CREATE OR REPLACE TABLE ... DEEP CLONE
克隆表 orders_archive (v1' → v2' → v3' → v4' ← 新版本)
                                            ↑ 只複製差異部分
```

---

## 📚 官方文件
- [Delta Lake Clone - Databricks Documentation](https://docs.databricks.com/delta/clone.html)
- [Incrementally Clone a Table](https://docs.databricks.com/delta/clone.html#incrementally-clone-a-table)

---

**[返回題目](#question-010)**
