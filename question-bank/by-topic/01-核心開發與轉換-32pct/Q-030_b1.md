# Question #030

---

## 題目資訊
### 題目編號
**ID:** `Q-030`

### 來源
**來源:** Sample / Batch 1

### 難度等級
**難度:** `L2-Intermediate`

---

## 題目內容
### 題幹
A data engineer wants to create a Delta Lake table for storing user activities of a website. The table has the following schema:

```
user_id LONG, page STRING, activity_type LONG, ip_address STRING, activity_time TIMESTAMP, activity_date DATE
```

Based on the above schema, which column is a good candidate for partitioning the Delta Table?

### 選項
- **A.** user_id

- **B.** activity_type

- **C.** activity_time

- **D.** activity_date

---

## 標籤系統
### Topic Tags (技術主題標籤)
**Topics:** `Delta-Lake`, `Partitioning`

### Trap Tags (陷阱類型標籤)
**Traps:** `Concept-Confusion`

### Knowledge Domain (知識領域)
**Domain:** Data Engineering / Data Modeling

---

## 答案與來源
### 正確答案
**正解:** `D`

### 答案來源
- **來源標註答案:** D
- **社群共識:** D

---

# 題目解析

---

## 📍 考點識別

**核心技術:** Delta Lake 分區設計最佳實踐

**關鍵概念:**
- 分區欄位的選擇標準
- 高基數 vs 低基數
- 時間序列資料的分區策略

**題目關鍵字：**
- **user activities**: 使用者活動日誌
- **partitioning**: 資料分區
- **DATE**: 日期類型欄位

---

## ✅ 正解說明

### 為什麼 D 是正確答案？

**技術原理：**

`activity_date` 是最佳的分區欄位，因為它符合分區設計的所有最佳實踐。

#### 分區欄位選擇標準

| 標準 | activity_date 評估 |
|------|-------------------|
| **基數適中** | ✅ 每天一個分區，不會太多也不會太少 |
| **查詢模式** | ✅ 通常按日期範圍查詢活動資料 |
| **資料分佈均勻** | ✅ 每天的活動量相對穩定 |
| **分區大小合理** | ✅ 每個分區約數 MB 到數 GB |
| **便於維護** | ✅ 可以輕鬆刪除或歸檔舊日期的分區 |

#### 建表語法

```sql
CREATE TABLE user_activities (
    user_id LONG,
    page STRING,
    activity_type LONG,
    ip_address STRING,
    activity_time TIMESTAMP,
    activity_date DATE
)
USING DELTA
PARTITIONED BY (activity_date);
```

#### 分區結構

```
user_activities/
├── activity_date=2024-01-01/
│   ├── part-00000.parquet
│   └── part-00001.parquet
├── activity_date=2024-01-02/
│   ├── part-00000.parquet
│   └── part-00001.parquet
├── activity_date=2024-01-03/
│   └── part-00000.parquet
└── _delta_log/
```

#### 查詢優化效果

```sql
-- 這個查詢會直接跳過不相關的分區
SELECT * FROM user_activities
WHERE activity_date = '2024-01-15';
-- 只掃描 activity_date=2024-01-15/ 這個分區

-- 範圍查詢也會受益
SELECT * FROM user_activities
WHERE activity_date BETWEEN '2024-01-01' AND '2024-01-07';
-- 只掃描 7 個分區
```

---

## ❌ 錯誤選項排除

### 選項 A
**user_id**

**為什麼錯誤？**

1. **高基數問題**：
   - 網站可能有數百萬使用者
   - 每個 user_id 一個分區 = 數百萬個分區
   - 會導致「小檔案問題」

2. **資料分佈不均**：
   - 活躍使用者的資料很多
   - 不活躍使用者的資料很少
   - 造成資料傾斜

```
不好的分區結構（user_id）：
user_activities/
├── user_id=1/           (1000 條記錄)
├── user_id=2/           (5 條記錄)
├── user_id=3/           (50000 條記錄) ← 活躍使用者，檔案很大
├── user_id=4/           (2 條記錄)
├── ...
└── user_id=1000000/     (1 條記錄)
```

---

### 選項 B
**activity_type**

**為什麼錯誤？**

1. **基數太低**：
   - 活動類型通常只有幾種（如：view, click, purchase）
   - 可能只有 5-10 個分區
   - 每個分區會非常大

2. **資料分佈不均**：
   - 某些活動類型（如 page_view）會非常多
   - 某些活動類型（如 purchase）會很少

```
不好的分區結構（activity_type）：
user_activities/
├── activity_type=1/     (10億條 - page_view)  ← 太大
├── activity_type=2/     (1億條 - click)
├── activity_type=3/     (100萬條 - purchase)   ← 太小
└── activity_type=4/     (1000條 - signup)      ← 太小
```

---

### 選項 C
**activity_time**

**為什麼錯誤？**

1. **基數過高**：
   - TIMESTAMP 精確到秒或毫秒
   - 可能產生數億個分區（每秒一個）
   - 嚴重的小檔案問題

2. **應該使用 DATE 而非 TIMESTAMP**：
   - `activity_date` 是經過設計的日期欄位
   - 已經從 `activity_time` 萃取出來
   - 專門用於分區目的

```
不好的分區結構（activity_time）：
user_activities/
├── activity_time=2024-01-01 00:00:01/  (1 條記錄)
├── activity_time=2024-01-01 00:00:02/  (3 條記錄)
├── activity_time=2024-01-01 00:00:03/  (2 條記錄)
├── ...                                  (數十億個分區!)
└── _delta_log/                          (metadata 膨脹)
```

---

## 🧠 記憶法

### 口訣
**「分區選日期，基數要適中」**
→ 時間序列資料用 DATE 分區，避免高基數（如 user_id）或低基數（如 type）

### 分區欄位選擇決策表

| 欄位特性 | 適合分區？ | 原因 |
|---------|----------|------|
| **低基數**（< 10） | ⚠️ 不建議 | 分區太少，每個分區太大 |
| **中等基數**（10-10000） | ✅ 適合 | 分區數量合理 |
| **高基數**（> 100000） | ❌ 不建議 | 太多小分區 |
| **DATE 類型** | ✅ 通常適合 | 基數適中，查詢常用 |
| **TIMESTAMP 類型** | ❌ 不建議 | 基數太高 |

### 分區最佳實踐

1. **每個分區至少 1 GB 資料**
   - 分區太小會影響讀取效能
   - 如果每天資料量 < 1 GB，考慮按週或月分區

2. **總分區數不超過 10000**
   - 過多分區會增加 metadata 負擔
   - 影響表格掃描效能

3. **選擇常用的過濾欄位**
   - 查詢通常會過濾日期
   - 分區裁剪可以大幅提升效能

### 現代替代方案：Liquid Clustering

```sql
-- 對於新表格，考慮使用 Liquid Clustering 而非傳統分區
CREATE TABLE user_activities (
    user_id LONG,
    page STRING,
    activity_type LONG,
    ip_address STRING,
    activity_time TIMESTAMP,
    activity_date DATE
)
CLUSTER BY (activity_date, user_id);

-- Liquid Clustering 優點：
-- 1. 不會產生小檔案問題
-- 2. 可以隨時調整 clustering key
-- 3. 自動平衡資料分佈
```

---

## 📚 官方文件

- [Delta Lake Partitioning](https://docs.databricks.com/en/tables/partitions.html)
- [Partition Columns Best Practices](https://docs.databricks.com/en/tables/partitions.html#choose-the-right-partition-column)
- [Liquid Clustering](https://docs.databricks.com/en/delta/clustering.html)

---

**[返回題目](#question-030)**
